minpos = 0
)
strategy(
strategy_st,
store = TRUE
)
# add indicator ----
add.indicator(
strategy = strategy_st,
name = "EMA",
arguments = list(x = quote(Cl(mktdata)), n = 50),
label = "ema_50"
)
# buy signal
add.signal(
strategy = strategy_st,
name = "sigComparison",
arguments = list(
columns = c("Close", "ema_50"),
relationship = "lt"
),
label = "BuySignal"
)
# buy rule
add.rule(
strategy = strategy_st,
name = "ruleSignal",
arguments = list(
sigcol = "BuySignal",
sigval = TRUE,
orderqty = 100,
ordertype = "market",
orderside = "long",
osFUN = osMaxPos,
replace = FALSE,
orderset = "ProfitTakerSet"
),
type = "enter",
label = "EnterRule"
)
# sell rule
add.rule(
strategy = strategy_st,
name = "ruleSignal",
arguments = list(
sigcol = "ExitSignal",
sigval = TRUE,
orderqty = "all",
ordertype = "limit",
orderside = "long",
replace = FALSE,
),
type = "exit",
label = "ExitRule"
)
rm(list = ls())
# libs ----
pacman::p_load(
quantmod,
TTR,
PerformanceAnalytics
)
# this libs were removed from CRAN
pacman::p_load_gh(
"braverock/FinancialInstrument",
"braverock/quantstrat",
"braverock/blotter"
)
# set time zone
Sys.setenv(tz = "UTC")
# set data ----
start_date <- "2000-01-01"
getSymbols("SPY",
src = "yahoo",
from = start_date,
auto.assign = TRUE
)
# define instrument
currency("USD")
stock("SPY",
currency = "USD",
multiplier = 1
)
# set strats ----
strategy_st <- "mean_revert"
portfolio_st <- "mean_revert"
account_st <- "mean_revert"
# clean old runs
.blotter <- new.env()
.strategy <- new.env()
rm.strat(strategy_st)
rm.strat(portfolio_st)
rm.strat(account_st)
# init portfolio ----
init_date <- "1999-12-31"
init_eq <- 10000
initPortf(
portfolio_st,
symbols = "SPY",
initDate = init_date,
currency = "USD",
initEq = init_eq
)
initAcct(
account_st,
portfolios = portfolio_st,
initDate = init_date,
currency = "USD",
initEq = init_eq
)
initOrders(
portfolio_st,
initDate = init_date
)
# define portfolio position limit
addPosLimit(
portfolio = portfolio_st,
symbol = "SPY",
timestamp = init_date,
maxpos = 100,
minpos = 0
)
strategy(
strategy_st,
store = TRUE
)
# add indicator ----
add.indicator(
strategy = strategy_st,
name = "EMA",
arguments = list(x = quote(Cl(mktdata)), n = 50),
label = "ema_50"
)
# buy signal
add.signal(
strategy = strategy_st,
name = "sigComparison",
arguments = list(
columns = c("Close", "ema_50"),
relationship = "lt"
),
label = "BuySignal"
)
# buy rule
add.rule(
strategy = strategy_st,
name = "ruleSignal",
arguments = list(
sigcol = "BuySignal",
sigval = TRUE,
orderqty = 100,
ordertype = "market",
orderside = "long",
osFUN = osMaxPos,
replace = FALSE,
orderset = "ProfitTakerSet"
),
type = "enter",
label = "EnterRule"
)
# sell rule
add.rule(
strategy = strategy_st,
name = "ruleSignal",
arguments = list(
sigcol = "ExitSignal",
sigval = TRUE,
orderqty = "all",
ordertype = "market",
orderside = "long",
replace = FALSE,
),
type = "exit",
label = "ExitRule"
)
s <- seq(0, 1, by = 0.001)
plot(abs(s)^-1, type = "l")
plot(abs(s)^-1, type = "l")
pacman::p_load(
tidyverse, cmdstanr, posterior, parallel, data.table, this.path
)
setwd(this.path::here())
pacman::p_load(
tidyverse, cmdstanr, posterior, parallel, data.table, this.path
)
setwd(this.path::here())
# data preparation ----
# loads raw data and maps behavioral events into a discrete state-action category.
d <- readRDS("../results/fit_full_volatility_final.rds")
d$draws()
# data preparation ----
# loads raw data and maps behavioral events into a discrete state-action category.
fits <- readRDS("../results/fit_full_volatility_final.rds")
draws <- fit$draws(variables = c("mu_beta", "mu_kappa", "mu_log_tau"), format = "df")
# data preparation ----
# loads raw data and maps behavioral events into a discrete state-action category.
fit <- readRDS("../results/fit_full_volatility_final.rds")
draws <- fit$draws(variables = c("mu_beta", "mu_kappa", "mu_log_tau"), format = "df")
draws
p_beta <- mcmc_areas(draws_beta, prob = 0.95, area_method = "scaled height") +
geom_vline(xintercept = 1, linetype = "dashed", color = "red") +
labs(title = "Relative Preference for Idleness (beta)",
subtitle = "fold-change relative to naive baseline",
x = "relative beta (utility / sec)") +
theme_minimal()
pacman::p_load(
tidyverse, cmdstanr, posterior, parallel, data.table, this.path
)
setwd(this.path::here())
# data preparation ----
# loads raw data and maps behavioral events into a discrete state-action category.
fit <- readRDS("../results/fit_full_volatility_final.rds")
draws <- fit$draws(variables = c("mu_beta", "mu_kappa", "mu_log_tau"), format = "df")
p_beta <- mcmc_areas(draws_beta, prob = 0.95, area_method = "scaled height") +
geom_vline(xintercept = 1, linetype = "dashed", color = "red") +
labs(title = "Relative Preference for Idleness (beta)",
subtitle = "fold-change relative to naive baseline",
x = "relative beta (utility / sec)") +
theme_minimal()
pacman::p_load(
tidyverse, cmdstanr, posterior, parallel, data.table, this.path, bayesplot
)
setwd(this.path::here())
# data preparation ----
# loads raw data and maps behavioral events into a discrete state-action category.
fit <- readRDS("../results/fit_full_volatility_final.rds")
draws <- fit$draws(variables = c("mu_beta", "mu_kappa", "mu_log_tau"), format = "df")
p_beta <- mcmc_areas(draws_beta, prob = 0.95, area_method = "scaled height") +
geom_vline(xintercept = 1, linetype = "dashed", color = "red") +
labs(title = "Relative Preference for Idleness (beta)",
subtitle = "fold-change relative to naive baseline",
x = "relative beta (utility / sec)") +
theme_minimal()
draws
draws_beta <- draw %>%
select(contains("mu_beta"))
draws_beta <- draws %>%
select(contains("mu_beta"))
draws_beta
p_beta <- mcmc_areas(draws_beta, prob = 0.95, area_method = "scaled height") +
geom_vline(xintercept = 1, linetype = "dashed", color = "red") +
labs(title = "Relative Preference for Idleness (beta)",
subtitle = "fold-change relative to naive baseline",
x = "relative beta (utility / sec)") +
theme_minimal()
p_beta
draws_beta <- draws %>%
select(contains("mu_beta"), -c("mu_beta[1,1]"))
p_beta <- mcmc_areas(draws_beta, prob = 0.95, area_method = "scaled height") +
geom_vline(xintercept = 1, linetype = "dashed", color = "red") +
labs(title = "Relative Preference for Idleness (beta)",
subtitle = "fold-change relative to naive baseline",
x = "relative beta (utility / sec)") +
theme_minimal()
p_beta
draws_beta <- draws %>%
select(contains("mu_beta"), !contains("mu_beta[1,*]"))
p_beta <- mcmc_areas(draws_beta, prob = 0.95, area_method = "scaled height") +
geom_vline(xintercept = 1, linetype = "dashed", color = "red") +
labs(title = "Relative Preference for Idleness (beta)",
subtitle = "fold-change relative to naive baseline",
x = "relative beta (utility / sec)") +
theme_minimal()
p_beta
draws_beta <- draws %>%
select(contains("mu_beta"), !contains("*[1,*]"))
p_beta <- mcmc_areas(draws_beta, prob = 0.95, area_method = "scaled height") +
geom_vline(xintercept = 1, linetype = "dashed", color = "red") +
labs(title = "Relative Preference for Idleness (beta)",
subtitle = "fold-change relative to naive baseline",
x = "relative beta (utility / sec)") +
theme_minimal()
p_beta
draws_beta <- draws %>%
select(!contains("mu_beta[1,*]"), contains("mu_beta*"))
p_beta <- mcmc_areas(draws_beta, prob = 0.95, area_method = "scaled height") +
geom_vline(xintercept = 1, linetype = "dashed", color = "red") +
labs(title = "Relative Preference for Idleness (beta)",
subtitle = "fold-change relative to naive baseline",
x = "relative beta (utility / sec)") +
theme_minimal()
p_beta
draws_beta <- draws %>%
select(contains("mu_beta"), -c("mu_beta[1,1]", "mu_beta[1,2]", "mu_beta[1,3]"))
p_beta <- mcmc_areas(draws_beta, prob = 0.95, area_method = "scaled height") +
geom_vline(xintercept = 1, linetype = "dashed", color = "red") +
labs(title = "Relative Preference for Idleness (beta)",
subtitle = "fold-change relative to naive baseline",
x = "relative beta (utility / sec)") +
theme_minimal()
p_beta
target_idx <- "[1,1]"
vars_to_plot <- c(
paste0("mu_beta", target_idx),
paste0("mu_log_tau", target_idx)
)
draws <- fit$draws(variables = vars_to_plot, format = "df") %>%
as_tibble() %>%
mutate(mu_tau = exp(.data[[paste0("mu_log_tau", target_idx)]]))
# 2. JOINT POSTERIOR VISUALIZATION (SCATTER) ----
# Categorical Intuition: The 'Shape' of Truth
# If the plot is a round circle: The parameters are independent (Well-Identified).
# If the plot is a diagonal 'banana': The parameters are coupled (Non-Identifiable).
p_joint <- ggplot(draws, aes(x = .data[[paste0("mu_beta", target_idx)]], y = mu_tau)) +
geom_bin2d(bins = 50) +
scale_fill_viridis_c(option = "plasma") +
geom_density_2d(color = "white", alpha = 0.5) +
theme_minimal() +
labs(
title = paste("Joint Posterior Manifold:", target_idx),
subtitle = "Diagonal elongation indicates a Motivation-Precision trade-off.",
x = "Motivation (mu_beta)",
y = "Decision Noise (mu_tau)"
)
# 3. TRACE OVERLAP (CONVERGENCE CHECK) ----
# We check if different chains are stuck in different peaks.
p_trace <- mcmc_trace(draws, pars = vars_to_plot) +
theme_minimal() +
labs(title = "Chain Trajectories (Are they jumping between peaks?)")
p_joint
p_trace
# 4. MARGINAL DENSITIES ----
p_dens <- mcmc_dens(draws, pars = vars_to_plot) +
theme_minimal() +
labs(title = "Marginal Distributions")
p_dens
# 5. ASSEMBLY ----
final_diag <- (p_joint | (p_dens / p_trace)) +
plot_layout(widths = c(2, 1))
# 6. NUMERICAL CORRELATION ----
# Formalizing the Coupling Strength
cor_val <- cor(draws[[paste0("mu_beta", target_idx)]], draws$mu_tau)
cor_vsl
cor_val
if(abs(cor_val) > 0.7) {
message("WARNING: High correlation detected. The model is struggling to separate vigor from noise.")
}
p_trace
p_dens
p_beta
color_scheme_set("viridis")
p_trace <- mcmc_trace(
draws,
pars = vars_to_plot,
facet_args = list(ncol = 1, strip.position = "left")
) +
theme_minimal() +
labs(
title = "Chain Trajectories (The Path Morphism)",
subtitle = "A 'Fuzzy Caterpillar' look indicates convergence to a single mode."
)
p_trace
target_idx <- "[1,1]"
vars_to_plot <- c(
paste0("mu_beta", target_idx),
paste0("mu_log_tau", target_idx)
)
draws <- fit$draws(variables = vars_to_plot, format = "df") %>%
as_tibble() %>%
mutate(mu_tau = exp(.data[[paste0("mu_log_tau", target_idx)]]))
# 2. JOINT POSTERIOR VISUALIZATION (SCATTER) ----
# Categorical Intuition: The 'Shape' of Truth
# If the plot is a round circle: The parameters are independent (Well-Identified).
# If the plot is a diagonal 'banana': The parameters are coupled (Non-Identifiable).
p_joint <- ggplot(draws, aes(x = .data[[paste0("mu_beta", target_idx)]], y = mu_tau)) +
geom_bin2d(bins = 50) +
scale_fill_viridis_c(option = "plasma") +
geom_density_2d(color = "white", alpha = 0.5) +
theme_minimal() +
labs(
title = paste("Joint Posterior Manifold:", target_idx),
subtitle = "Diagonal elongation indicates a Motivation-Precision trade-off.",
x = "Motivation (mu_beta)",
y = "Decision Noise (mu_tau)"
)
# 3. TRACE OVERLAP (CONVERGENCE CHECK) ----
# We check if different chains are stuck in different peaks.
p_trace <- mcmc_trace(draws, pars = vars_to_plot) +
theme_minimal() +
labs(title = "Chain Trajectories (Are they jumping between peaks?)")
color_scheme_set("viridis")
p_trace <- mcmc_trace(
draws,
pars = vars_to_plot,
facet_args = list(ncol = 1, strip.position = "left")
) +
theme_minimal() +
labs(
title = "Chain Trajectories (The Path Morphism)",
subtitle = "A 'Fuzzy Caterpillar' look indicates convergence to a single mode."
)
# 4. MARGINAL DENSITIES ----
p_dens <- mcmc_dens(draws, pars = vars_to_plot) +
theme_minimal() +
labs(title = "Marginal Distributions")
# 5. ASSEMBLY ----
final_diag <- (p_joint | (p_dens / p_trace)) +
plot_layout(widths = c(2, 1))
# Export ----
dir.create("../results/diagnostics", showWarnings = FALSE)
p_trace
# 1. LOAD FIT AND EXTRACT TARGETS ----
fit <- readRDS("../results/fit_full_volatility_final.rds")
# We target [1,1] (Naive/Baseline) as the primary diagnostic anchor.
target_idx <- "[1,1]"
vars_to_plot <- c(
paste0("mu_beta", target_idx),
paste0("mu_log_tau", target_idx)
)
# Categorical Fix: Extract as an array to preserve the 'Chain' dimension
# draws_array preserves the structure [Iteration, Chain, Parameter]
draws_array <- fit$draws(variables = vars_to_plot)
# Create a flattened version for joint/marginal plots
draws_df <- as_draws_df(draws_array) %>%
mutate(mu_tau = exp(.data[[paste0("mu_log_tau", target_idx)]]))
# 2. JOINT POSTERIOR VISUALIZATION (SCATTER) ----
# Categorical Intuition: The 'Shape' of Truth
p_joint <- ggplot(draws_df, aes(x = .data[[paste0("mu_beta", target_idx)]], y = mu_tau)) +
geom_bin2d(bins = 50) +
scale_fill_viridis_c(option = "plasma") +
geom_density_2d(color = "white", alpha = 0.5) +
theme_minimal() +
labs(
title = paste("Joint Posterior Manifold:", target_idx),
subtitle = "Diagonal elongation indicates a Motivation-Precision trade-off.",
x = "Motivation (mu_beta)",
y = "Decision Noise (mu_tau)"
)
# 3. TRACE OVERLAP (CONVERGENCE CHECK) ----
# Logical Correction: We pass the draws_array here.
# Because draws_array is a 3D structure, bayesplot can reconstruct all 4 Path Morphisms.
color_scheme_set("viridis")
p_trace <- mcmc_trace(
draws_array,
pars = vars_to_plot,
facet_args = list(ncol = 1, strip.position = "left")
) +
theme_minimal() +
labs(
title = "Chain Trajectories (The Path Morphism)",
subtitle = "A 'Fuzzy Caterpillar' look indicates convergence to a single mode."
)
p_trace
pacman::p_load(
tidyverse, posterior, bayesplot, patchwork, scales, this.path
)
setwd(this.path::here())
# 1. LOAD FIT AND EXTRACT TARGETS ----
fit <- readRDS("../results/fit_full_volatility_final.rds")
# We target [1,1] (Naive/Baseline) as the primary diagnostic anchor.
target_idx <- "[1,1]"
vars_to_plot <- c(
paste0("mu_beta", target_idx),
paste0("mu_log_tau", target_idx)
)
# Preserve the 'Chain' dimension to diagnose the divergence
draws_array <- fit$draws(variables = vars_to_plot)
# Create a chain-aware data frame for diagnostics
draws_df <- as_draws_df(draws_array) %>%
mutate(
mu_tau = exp(.data[[paste0("mu_log_tau", target_idx)]]),
Chain = as.factor(.chain)
)
# 2. CHAIN-AWARE JOINT POSTERIOR (IDENTIFYING ISLANDS) ----
# Categorical Intuition: Mapping the 'Island' problem.
# If the divergent chain is a different color in a different region,
# the manifold is multi-modal or poorly identified.
p_joint <- ggplot(draws_df, aes(x = .data[[paste0("mu_beta", target_idx)]], y = mu_tau, color = Chain)) +
geom_point(alpha = 0.2, size = 0.5) +
geom_density_2d(alpha = 0.5) +
scale_color_viridis_d() +
theme_minimal() +
labs(
title = "Chain-Aware Joint Posterior",
subtitle = "Check if the divergent chain (color) is isolated from the others.",
x = "Motivation (mu_beta)",
y = "Decision Noise (mu_tau)"
) +
guides(color = guide_legend(override.aes = list(alpha = 1, size = 2)))
# 3. TRACE OVERLAP (THE PATH MORPHISM) ----
color_scheme_set("viridis")
p_trace <- mcmc_trace(
draws_array,
pars = vars_to_plot,
facet_args = list(ncol = 1, strip.position = "left")
) +
theme_minimal() +
labs(
title = "Chain Trajectories (Divergence Check)",
subtitle = "A divergent chain will appear as a 'wandering' line outside the main caterpillar."
)
# 4. MARGINAL DENSITIES BY CHAIN ----
p_dens <- mcmc_dens_overlay(draws_array, pars = vars_to_plot) +
theme_minimal() +
labs(title = "Overlaid Marginal Densities")
# 5. ASSEMBLY ----
final_diag <- (p_joint | (p_dens / p_trace)) +
plot_layout(widths = c(2, 1))
# 6. NUMERICAL DIVERGENCE DIAGNOSTICS ----
# We extract the 'sampler_diagnostics' to see if the chain hit the treedepth limit.
sampler_diags <- fit$sampler_diagnostics()
div_counts <- apply(sampler_diags[, , "divergent__"], 2, sum)
max_td <- apply(sampler_diags[, , "treedepth__"], 2, max)
message("--- Sampler Diagnostics per Chain ---")
for(i in 1:length(div_counts)) {
message(paste("Chain", i, "- Divergences:", div_counts[i], "| Max Treedepth:", max_td[i]))
}
# 7. CORRELATION (CLEAN CHAINS ONLY) ----
# We calculate correlation excluding the divergent chain to see the 'true' manifold.
clean_draws <- draws_df %>% filter(Chain != which.max(div_counts))
cor_val <- cor(clean_draws[[paste0("mu_beta", target_idx)]], clean_draws$mu_tau)
message(paste("\nCorrelation (excluding divergent chain):", round(cor_val, 3)))
