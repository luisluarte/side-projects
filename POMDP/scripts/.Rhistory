rename_vec[old_pattern_beta] <- new_label_beta
rename_vec[old_pattern_kappa] <- new_label_kappa
rename_vec[old_pattern_tau] <- new_label_tau
}
}
# Apply the labeling morphism to the column names
colnames(draws) <- ifelse(colnames(draws) %in% names(rename_vec),
rename_vec[colnames(draws)],
colnames(draws)
)
# Plotting with human-readable axis labels
plot_beta <- mcmc_areas(draws, pars = vars(starts_with("Beta")), prob = 0.95) +
ggtitle("Intrinsic Motivation (Beta) by Condition and Context") +
theme_minimal()
plot_beta
plot_kappa
plot_tau
# ==============================================================================
# HIERARCHICAL POMDP ANALYSIS: SEPARABLE MODEL
# ==============================================================================
# Categorical Formalization: Population Shift via Trait-State Direct Sum.
# Logical Correction: Training (na_na_na_na) restricted to Baseline Context.
# ==============================================================================
pacman::p_load(
tidyverse, cmdstanr, posterior, bayesplot, parallel, data.table, this.path
)
setwd(this.path::here())
# 1. DATA PREPARATION & CODING ----
d <- readRDS("../data/processed/discrete_data.rds")
coded_d <- d %>%
mutate(
A = case_when(
A == "a_W" ~ 1, A == "a_P" ~ 2, A == "a_SP" ~ 3,
A == "a_LP" ~ 4, A == "a_L1" ~ 5, A == "a_L2" ~ 6
),
S = case_when(
S == "S_I" ~ 1, S == "S_P1" ~ 2, S == "S_P2" ~ 3, S == "S_Armed" ~ 4,
S == "S_1_0" ~ 5, S == "S_2_0" ~ 6, S == "S_3_0" ~ 7, S == "S_4_0" ~ 8,
S == "S_0_1" ~ 9, S == "S_0_2" ~ 10, S == "S_0_3" ~ 11, S == "S_0_4" ~ 12,
S == "S_CR" ~ 99, S == "S_CN" ~ 100
)
) %>%
filter(!is.na(A), !is.na(S)) %>%
mutate(next_S = lead(S, default = 1))
compressed_d <- coded_d %>%
mutate(
outcome_event = next_S %in% c(99, 100),
run_id = rleid(ID, n_sesion, S, A, next_S, outcome_event)
) %>%
group_by(run_id) %>%
summarise(
ID = first(ID), n_sesion = first(n_sesion), droga = first(droga),
true_context = first(true_context), S = first(S), A = first(A),
next_S = first(next_S), weight = n(), .groups = "drop"
)
# 2. PHYSICS ENGINE CALIBRATION ----
fr5_cost <- coded_d %>%
filter(droga == "na_na_na_na", is_datum == TRUE, n_sesion %in% 15:17) %>%
group_by(ID) %>%
mutate(ILI_ms = timestamp - lag(timestamp)) %>%
filter(S %in% 5:12, ILI_ms > 0, ILI_ms <= 1000) %>%
summarise(mean_ili_ms = mean(ILI_ms, na.rm = TRUE), .groups = "drop") %>%
mutate(lick_cost_steps = round(mean_ili_ms / 25))
travel_cost <- coded_d %>%
filter(droga == "na_na_na_na", A %in% 4:6, n_sesion %in% 15:17) %>%
group_by(ID) %>%
mutate(is_leave = A == 4, is_lick = A %in% 5:6, travel_group = cumsum(is_leave)) %>%
filter(is_leave | is_lick) %>%
group_by(ID, travel_group) %>%
summarise(
time_leave = min(timestamp[is_leave]), time_first_lick = min(timestamp[is_lick]),
has_leave = any(is_leave), has_lick = any(is_lick), .groups = "drop"
) %>%
filter(has_leave, has_lick) %>%
mutate(travel_time = time_first_lick - time_leave) %>%
filter(travel_time > 25) %>%
group_by(ID) %>%
summarise(fast_travel_ms = quantile(travel_time, 0.10, na.rm = TRUE), .groups = "drop") %>%
mutate(travel_cost_steps = round(fast_travel_ms / 25))
animal_physics <- full_join(fr5_cost, travel_cost, by = "ID") %>%
mutate(
lick_cost_steps = replace_na(lick_cost_steps, 6),
travel_cost_steps = replace_na(travel_cost_steps, 20),
poke_cost_steps = 2
)
# 3. CALCULATE Q* ----
GAMMA <- 0.99
N_LICK_CHAIN <- 5
N_PHYS_CONTEXTS <- 5
N_STATES <- 100
N_ACTIONS <- 6
N_ANIMALS <- nrow(animal_physics)
CTX_PROBS <- matrix(c(0.99, 0.99, 0.50, 0.99, 0.99, 0.50, 0.25, 0.50, 0.50, 0.25), ncol = 2, byrow = TRUE)
calc_chain_value <- function(p_reward, k, lick_cost) {
v_outcome <- p_reward
licks_needed <- N_LICK_CHAIN - k
if (licks_needed <= 0) {
return(v_outcome)
}
return((GAMMA^(lick_cost * licks_needed)) * v_outcome)
}
Q_STAR <- array(0, dim = c(N_ANIMALS, N_PHYS_CONTEXTS, N_STATES, N_ACTIONS))
for (a in 1:N_ANIMALS) {
a_params <- animal_physics[a, ]
L_C <- a_params$lick_cost_steps
T_C <- a_params$travel_cost_steps
P_C <- a_params$poke_cost_steps
for (c in 1:N_PHYS_CONTEXTS) {
p1 <- CTX_PROBS[c, 1]
p2 <- CTX_PROBS[c, 2]
for (k in 0:4) {
sid_l <- if (k == 0) 4 else (4 + k)
sid_r <- if (k == 0) 4 else (8 + k)
if (sid_l != 4) {
Q_STAR[a, c, sid_l, 5] <- (GAMMA^L_C) * calc_chain_value(p1, k + 1, L_C)
Q_STAR[a, c, sid_l, 6] <- (GAMMA^(T_C + L_C)) * calc_chain_value(p2, 1, L_C)
}
if (sid_r != 4) {
Q_STAR[a, c, sid_r, 6] <- (GAMMA^L_C) * calc_chain_value(p2, k + 1, L_C)
Q_STAR[a, c, sid_r, 5] <- (GAMMA^(T_C + L_C)) * calc_chain_value(p1, 1, L_C)
}
}
Q_STAR[a, c, 4, 5] <- (GAMMA^(T_C + L_C)) * calc_chain_value(p1, 1, L_C)
Q_STAR[a, c, 4, 6] <- (GAMMA^(T_C + L_C)) * calc_chain_value(p2, 1, L_C)
Q_STAR[a, c, 3, 4] <- max(Q_STAR[a, c, 4, 5:6]) * GAMMA
Q_STAR[a, c, 2, 3] <- Q_STAR[a, c, 3, 4] * GAMMA
Q_STAR[a, c, 1, 2] <- Q_STAR[a, c, 2, 3] * (GAMMA^P_C)
}
}
# 4. MAPPING & PARTITIONING (Quotient Transformation) ----
animal_map <- tibble(ID = animal_physics$ID) %>% mutate(animal_idx = row_number())
# CONSISTENT BASELINE MAPPING: Collapsing placebos into a single category
compressed_d <- compressed_d %>%
mutate(
droga_mapped = case_when(
droga == "na_na_na_na" ~ "Baseline",
droga == "veh_na_na_na" ~ "Baseline",
TRUE ~ droga
)
)
drug_map <- tibble(droga = unique(compressed_d$droga_mapped)) %>%
mutate(drug_id = row_number()) %>%
# Ensure Baseline is always ID 1
arrange(desc(droga == "Baseline")) %>%
mutate(drug_id = row_number())
# Metadata for Human-Readable Plots
cognitive_context_map <- tibble(
cog_idx = 1:3,
group_name = c("Baseline (1-1 probs)", "Moderate (50-99 probs)", "High (25-50 probs)")
)
compressed_d <- compressed_d %>%
left_join(animal_map, by = "ID") %>%
mutate(
phys_ctx_id = case_when(
true_context == "C_T" ~ 1, true_context == "C_S2a" ~ 2,
true_context == "C_S2b" ~ 3, true_context == "C_S3a" ~ 4,
true_context == "C_S3b" ~ 5
),
# LOGICAL CONSTRAINT: Training (na_na_na_na) MUST be Baseline Context (cog_idx=1)
# Even if the true_context log says otherwise, training is always CT.
cog_ctx_id = case_when(
droga == "na_na_na_na" ~ 1,
phys_ctx_id == 1 ~ 1,
phys_ctx_id %in% 2:3 ~ 2,
TRUE ~ 3
)
)
sessions_df <- compressed_d %>%
group_by(animal_idx, n_sesion) %>%
summarise(
start_idx = min(row_number()), end_idx = max(row_number()),
phys_ctx = first(phys_ctx_id), cog_ctx = first(cog_ctx_id),
# Map to the new consolidated drug IDs
drug_id = drug_map$drug_id[drug_map$droga == first(droga_mapped)],
.groups = "drop"
)
animal_sessions <- sessions_df %>%
group_by(animal_idx) %>%
summarise(s_start = min(row_number()), s_end = max(row_number()))
# 5. EXECUTION ----
stan_data <- list(
N_animals = N_ANIMALS, N_sessions_total = nrow(sessions_df), N_compressed_steps = nrow(compressed_d),
N_drugs = nrow(drug_map), N_physics_contexts = N_PHYS_CONTEXTS, N_cognitive_contexts = 3,
sessions_per_animal_start = animal_sessions$s_start, sessions_per_animal_end = animal_sessions$s_end,
session_physics_context = sessions_df$phys_ctx, session_cognitive_context = sessions_df$cog_ctx,
session_drug = sessions_df$drug_id, state_id = compressed_d$S, action_id = compressed_d$A,
next_state_id = compressed_d$next_S, weight = compressed_d$weight,
start_idx = sessions_df$start_idx, end_idx = sessions_df$end_idx,
N_actions = N_ACTIONS, N_states = 100, Q_star = aperm(Q_STAR, c(2, 1, 3, 4)),
context_probs = CTX_PROBS, ID_IDLE = 1, ID_WAIT = 1, ID_LICK1 = 5, ID_LICK2 = 6,
ID_REWARD_STATE = 99, ID_NOREWARD_STATE = 100, grainsize = 1
)
mod <- cmdstan_model("pomdp_model.stan", cpp_options = list(stan_threads = TRUE))
fit <- mod$pathfinder(data = stan_data, num_threads = detectCores())
# 6. VISUALIZATION (Human-Readable Renaming) ----
message("Renaming posterior draws for readability...")
draws <- fit$draws(variables = c("mu_beta", "mu_kappa", "mu_log_tau"), format = "df")
# Create a renaming vector for the posterior columns
rename_vec <- c()
for (d in 1:nrow(drug_map)) {
for (c in 1:3) {
d_label <- drug_map$droga[d]
c_label <- cognitive_context_map$group_name[c]
# Matrix indexing in Stan mu_beta[drug, context]
old_pattern_beta <- paste0("mu_beta[", d, ",", c, "]")
old_pattern_kappa <- paste0("mu_kappa[", d, ",", c, "]")
old_pattern_tau <- paste0("mu_log_tau[", d, ",", c, "]")
new_label_beta <- paste0("Beta: ", d_label, " | ", c_label)
new_label_kappa <- paste0("Kappa: ", d_label, " | ", c_label)
new_label_tau <- paste0("Log-Tau: ", d_label, " | ", c_label)
rename_vec[old_pattern_beta] <- new_label_beta
rename_vec[old_pattern_kappa] <- new_label_kappa
rename_vec[old_pattern_tau] <- new_label_tau
}
}
# Apply the labeling morphism to the column names
colnames(draws) <- ifelse(colnames(draws) %in% names(rename_vec),
rename_vec[colnames(draws)],
colnames(draws)
)
# Plotting with human-readable axis labels
plot_beta <- mcmc_areas(draws, pars = vars(starts_with("Beta")), prob = 0.95) +
ggtitle("Intrinsic Motivation (Beta) by Condition and Context") +
theme_minimal()
plot_kappa <- mcmc_areas(draws, pars = vars(starts_with("Kappa")), prob = 0.95) +
ggtitle("Information Seeking (Kappa) by Condition and Context") +
theme_minimal()
plot_tau <- mcmc_areas(draws, pars = vars(starts_with("Log-Tau")), prob = 0.95) +
ggtitle("Decision Noise (Log-Tau) by Condition and Context") +
theme_minimal()
# Save the semantic results
ggsave("../results/beta_readable.pdf", plot_beta, width = 10, height = 8)
ggsave("../results/kappa_readable.pdf", plot_kappa, width = 10, height = 8)
ggsave("../results/tau_readable.pdf", plot_tau, width = 10, height = 8)
plot_beta
plot_kappa
draws
View(draws)
# ==============================================================================
# HIERARCHICAL POMDP ANALYSIS: RIGID SEPARABLE MODEL
# ==============================================================================
# Categorical Formalization: Natural Transformation as Global Trait (Rigid Personality)
# LME4 Translation: parameter ~ drug * context + (1 | animal)
# ==============================================================================
pacman::p_load(
tidyverse, cmdstanr, posterior, bayesplot, parallel, data.table, this.path
)
setwd(this.path::here())
# 1. DATA PREPARATION ----
d <- readRDS("../data/processed/discrete_data.rds")
coded_d <- d %>%
mutate(
A = case_when(
A == "a_W" ~ 1, A == "a_P" ~ 2, A == "a_SP" ~ 3,
A == "a_LP" ~ 4, A == "a_L1" ~ 5, A == "a_L2" ~ 6
),
S = case_when(
S == "S_I" ~ 1, S == "S_P1" ~ 2, S == "S_P2" ~ 3, S == "S_Armed" ~ 4,
S == "S_1_0" ~ 5, S == "S_2_0" ~ 6, S == "S_3_0" ~ 7, S == "S_4_0" ~ 8,
S == "S_0_1" ~ 9, S == "S_0_2" ~ 10, S == "S_0_3" ~ 11, S == "S_0_4" ~ 12,
S == "S_CR" ~ 99, S == "S_CN" ~ 100
)
) %>%
filter(!is.na(A), !is.na(S)) %>%
mutate(next_S = lead(S, default = 1))
compressed_d <- coded_d %>%
mutate(
outcome_event = next_S %in% c(99, 100),
run_id = rleid(ID, n_sesion, S, A, next_S, outcome_event)
) %>%
group_by(run_id) %>%
summarise(
ID = first(ID), n_sesion = first(n_sesion), droga = first(droga),
true_context = first(true_context), S = first(S), A = first(A),
next_S = first(next_S), weight = n(), .groups = "drop"
)
# 2. PHYSICS CALIBRATION ----
animal_physics <- compressed_d %>%
filter(droga == "na_na_na_na") %>%
group_by(ID) %>%
summarise(
lick_cost_steps = 6, travel_cost_steps = 20, poke_cost_steps = 2,
.groups = "drop"
)
# 3. Q* CALCULATION (VALUATION FUNCTOR) ----
GAMMA <- 0.99
N_PHYS_CONTEXTS <- 5
N_STATES <- 100
N_ACTIONS <- 6
N_ANIMALS <- nrow(animal_physics)
CTX_PROBS <- matrix(c(0.99, 0.99, 0.50, 0.99, 0.99, 0.50, 0.25, 0.50, 0.50, 0.25), ncol = 2, byrow = TRUE)
Q_STAR <- array(0, dim = c(N_ANIMALS, N_PHYS_CONTEXTS, N_STATES, N_ACTIONS))
# (Logic omitted for brevity, assuming standard backwards induction as established)
# 4. MAPPING (RIGID QUOTIENT) ----
animal_map <- tibble(ID = animal_physics$ID) %>% mutate(animal_idx = row_number())
compressed_d <- compressed_d %>%
mutate(droga_mapped = ifelse(droga %in% c("na_na_na_na", "veh_na_na_na"), "Baseline", droga))
drug_map <- tibble(droga = unique(compressed_d$droga_mapped)) %>%
arrange(desc(droga == "Baseline")) %>%
mutate(drug_id = row_number())
compressed_d <- compressed_d %>%
left_join(animal_map, by = "ID") %>%
mutate(
phys_ctx_id = case_when(
true_context == "C_T" ~ 1, true_context == "C_S2a" ~ 2,
true_context == "C_S2b" ~ 3, true_context == "C_S3a" ~ 4, TRUE ~ 5
),
cog_ctx_id = case_when(droga == "na_na_na_na" ~ 1, phys_ctx_id == 1 ~ 1, phys_ctx_id %in% 2:3 ~ 2, TRUE ~ 3)
)
sessions_df <- compressed_d %>%
group_by(animal_idx, n_sesion) %>%
summarise(
start_idx = min(row_number()), end_idx = max(row_number()),
phys_ctx = first(phys_ctx_id), cog_ctx = first(cog_ctx_id),
drug_id = drug_map$drug_id[drug_map$droga == first(droga_mapped)],
.groups = "drop"
)
animal_sessions <- sessions_df %>%
group_by(animal_idx) %>%
summarise(s_start = min(row_number()), s_end = max(row_number()))
# 5. EXECUTION (MCMC SAMPLING) ----
stan_data <- list(
N_animals = N_ANIMALS, N_sessions_total = nrow(sessions_df), N_compressed_steps = nrow(compressed_d),
N_drugs = nrow(drug_map), N_physics_contexts = N_PHYS_CONTEXTS, N_cognitive_contexts = 3,
sessions_per_animal_start = animal_sessions$s_start, sessions_per_animal_end = animal_sessions$s_end,
session_physics_context = sessions_df$phys_ctx, session_cognitive_context = sessions_df$cog_ctx,
session_drug = sessions_df$drug_id, state_id = compressed_d$S, action_id = compressed_d$A,
next_state_id = compressed_d$next_S, weight = compressed_d$weight,
start_idx = sessions_df$start_idx, end_idx = sessions_df$end_idx,
N_actions = N_ACTIONS, N_states = N_STATES, Q_star = aperm(Q_STAR, c(2, 1, 3, 4)),
context_probs = CTX_PROBS, ID_IDLE = 1, ID_WAIT = 1, ID_LICK1 = 5, ID_LICK2 = 6,
ID_REWARD_STATE = 99, ID_NOREWARD_STATE = 100, grainsize = 1
)
mod <- cmdstan_model("pomdp_model.stan", cpp_options = list(stan_threads = TRUE))
fit <- mod$sample(data = stan_data, chains = 4, parallel_chains = 4, iter_sampling = 500, init = 0)
# ==============================================================================
# HIERARCHICAL POMDP ANALYSIS: RIGID SEPARABLE MODEL
# ==============================================================================
# Categorical Formalization: Natural Transformation as Global Trait (Rigid Personality)
# LME4 Translation: parameter ~ drug * context + (1 | animal)
# ==============================================================================
pacman::p_load(
tidyverse, cmdstanr, posterior, bayesplot, parallel, data.table, this.path
)
setwd(this.path::here())
# 1. DATA PREPARATION ----
d <- readRDS("../data/processed/discrete_data.rds")
coded_d <- d %>%
mutate(
A = case_when(
A == "a_W" ~ 1, A == "a_P" ~ 2, A == "a_SP" ~ 3,
A == "a_LP" ~ 4, A == "a_L1" ~ 5, A == "a_L2" ~ 6
),
S = case_when(
S == "S_I" ~ 1, S == "S_P1" ~ 2, S == "S_P2" ~ 3, S == "S_Armed" ~ 4,
S == "S_1_0" ~ 5, S == "S_2_0" ~ 6, S == "S_3_0" ~ 7, S == "S_4_0" ~ 8,
S == "S_0_1" ~ 9, S == "S_0_2" ~ 10, S == "S_0_3" ~ 11, S == "S_0_4" ~ 12,
S == "S_CR" ~ 99, S == "S_CN" ~ 100
)
) %>%
filter(!is.na(A), !is.na(S)) %>%
mutate(next_S = lead(S, default = 1))
compressed_d <- coded_d %>%
mutate(
outcome_event = next_S %in% c(99, 100),
run_id = rleid(ID, n_sesion, S, A, next_S, outcome_event)
) %>%
group_by(run_id) %>%
summarise(
ID = first(ID), n_sesion = first(n_sesion), droga = first(droga),
true_context = first(true_context), S = first(S), A = first(A),
next_S = first(next_S), weight = n(), .groups = "drop"
)
# 2. PHYSICS CALIBRATION ----
animal_physics <- compressed_d %>%
filter(droga == "na_na_na_na") %>%
group_by(ID) %>%
summarise(
lick_cost_steps = 6, travel_cost_steps = 20, poke_cost_steps = 2,
.groups = "drop"
)
# 3. Q* CALCULATION (VALUATION FUNCTOR) ----
GAMMA <- 0.99
N_PHYS_CONTEXTS <- 5
N_STATES <- 100
N_ACTIONS <- 6
N_ANIMALS <- nrow(animal_physics)
CTX_PROBS <- matrix(c(0.99, 0.99, 0.50, 0.99, 0.99, 0.50, 0.25, 0.50, 0.50, 0.25), ncol = 2, byrow = TRUE)
Q_STAR <- array(0, dim = c(N_ANIMALS, N_PHYS_CONTEXTS, N_STATES, N_ACTIONS))
# (Logic omitted for brevity, assuming standard backwards induction as established)
# 4. MAPPING (RIGID QUOTIENT) ----
animal_map <- tibble(ID = animal_physics$ID) %>% mutate(animal_idx = row_number())
compressed_d <- compressed_d %>%
mutate(droga_mapped = ifelse(droga %in% c("na_na_na_na", "veh_na_na_na"), "Baseline", droga))
drug_map <- tibble(droga = unique(compressed_d$droga_mapped)) %>%
arrange(desc(droga == "Baseline")) %>%
mutate(drug_id = row_number())
compressed_d <- compressed_d %>%
left_join(animal_map, by = "ID") %>%
mutate(
phys_ctx_id = case_when(
true_context == "C_T" ~ 1, true_context == "C_S2a" ~ 2,
true_context == "C_S2b" ~ 3, true_context == "C_S3a" ~ 4, TRUE ~ 5
),
cog_ctx_id = case_when(droga == "na_na_na_na" ~ 1, phys_ctx_id == 1 ~ 1, phys_ctx_id %in% 2:3 ~ 2, TRUE ~ 3)
)
sessions_df <- compressed_d %>%
group_by(animal_idx, n_sesion) %>%
summarise(
start_idx = min(row_number()), end_idx = max(row_number()),
phys_ctx = first(phys_ctx_id), cog_ctx = first(cog_ctx_id),
drug_id = drug_map$drug_id[drug_map$droga == first(droga_mapped)],
.groups = "drop"
)
animal_sessions <- sessions_df %>%
group_by(animal_idx) %>%
summarise(s_start = min(row_number()), s_end = max(row_number()))
# 5. EXECUTION (PATHFINDER APPROXIMATION) ----
stan_data <- list(
N_animals = N_ANIMALS, N_sessions_total = nrow(sessions_df), N_compressed_steps = nrow(compressed_d),
N_drugs = nrow(drug_map), N_physics_contexts = N_PHYS_CONTEXTS, N_cognitive_contexts = 3,
sessions_per_animal_start = animal_sessions$s_start, sessions_per_animal_end = animal_sessions$s_end,
session_physics_context = sessions_df$phys_ctx, session_cognitive_context = sessions_df$cog_ctx,
session_drug = sessions_df$drug_id, state_id = compressed_d$S, action_id = compressed_d$A,
next_state_id = compressed_d$next_S, weight = compressed_d$weight,
start_idx = sessions_df$start_idx, end_idx = sessions_df$end_idx,
N_actions = N_ACTIONS, N_states = N_STATES, Q_star = aperm(Q_STAR, c(2, 1, 3, 4)),
context_probs = CTX_PROBS, ID_IDLE = 1, ID_WAIT = 1, ID_LICK1 = 5, ID_LICK2 = 6,
ID_REWARD_STATE = 99, ID_NOREWARD_STATE = 100, grainsize = 1
)
mod <- cmdstan_model("pomdp_model.stan", cpp_options = list(stan_threads = TRUE))
# Use Pathfinder for speed and local manifold approximation
fit <- mod$pathfinder(
data = stan_data,
num_paths = 4,
single_path_draws = 200,
num_threads = parallel::detectCores()
)
# 6. VISUALIZATION ----
draws <- fit$draws(variables = c("mu_beta", "mu_kappa", "mu_log_tau"), format = "df")
# (Renaming logic follows previous metadata mapping)
mcmc_areas(draws, pars = vars(starts_with("mu_beta")), prob = 0.95) +
ggtitle("Rigid Separable Model: Beta Posteriors (Pathfinder Approximation)") +
theme_minimal()
# 6. VISUALIZATION ----
draws <- fit$draws(variables = c("mu_beta", "mu_kappa", "mu_log_tau"), format = "df")
# Create a renaming vector for the posterior columns
rename_vec <- c()
for (d in 1:nrow(drug_map)) {
for (c in 1:nrow(cognitive_context_map)) {
d_label <- drug_map$droga[d]
c_label <- cognitive_context_map$group_name[c]
# Identify the abstract matrix positions in the Stan output
old_pattern_beta <- paste0("mu_beta[", d, ",", c, "]")
old_pattern_kappa <- paste0("mu_kappa[", d, ",", c, "]")
old_pattern_tau <- paste0("mu_log_tau[", d, ",", c, "]")
# Define the semantic labels
new_label_beta <- paste0("Beta: ", d_label, " | ", c_label)
new_label_kappa <- paste0("Kappa: ", d_label, " | ", c_label)
new_label_tau <- paste0("Log-Tau: ", d_label, " | ", c_label)
# Store in the mapping vector
rename_vec[old_pattern_beta] <- new_label_beta
rename_vec[old_pattern_kappa] <- new_label_kappa
rename_vec[old_pattern_tau] <- new_label_tau
}
}
# Metadata for Human-Readable Plots
cognitive_context_map <- tibble(
cog_idx = 1:3,
group_name = c("Baseline (1-1 probs)", "Moderate (50-99 probs)", "High (25-50 probs)")
)
# 6. VISUALIZATION ----
draws <- fit$draws(variables = c("mu_beta", "mu_kappa", "mu_log_tau"), format = "df")
# Create a renaming vector for the posterior columns
rename_vec <- c()
for (d in 1:nrow(drug_map)) {
for (c in 1:nrow(cognitive_context_map)) {
d_label <- drug_map$droga[d]
c_label <- cognitive_context_map$group_name[c]
# Identify the abstract matrix positions in the Stan output
old_pattern_beta <- paste0("mu_beta[", d, ",", c, "]")
old_pattern_kappa <- paste0("mu_kappa[", d, ",", c, "]")
old_pattern_tau <- paste0("mu_log_tau[", d, ",", c, "]")
# Define the semantic labels
new_label_beta <- paste0("Beta: ", d_label, " | ", c_label)
new_label_kappa <- paste0("Kappa: ", d_label, " | ", c_label)
new_label_tau <- paste0("Log-Tau: ", d_label, " | ", c_label)
# Store in the mapping vector
rename_vec[old_pattern_beta] <- new_label_beta
rename_vec[old_pattern_kappa] <- new_label_kappa
rename_vec[old_pattern_tau] <- new_label_tau
}
}
# Apply the labeling morphism: replace abstract names with semantic ones
colnames(draws) <- ifelse(colnames(draws) %in% names(rename_vec),
rename_vec[colnames(draws)],
colnames(draws)
)
# Generate semantic plots
plot_beta <- mcmc_areas(draws, pars = vars(starts_with("Beta")), prob = 0.95) +
ggtitle("Intrinsic Motivation (Beta) by Condition and Context") +
theme_minimal()
plot_beta
plot_kappa <- mcmc_areas(draws, pars = vars(starts_with("Kappa")), prob = 0.95) +
ggtitle("Information Seeking (Kappa) by Condition and Context") +
theme_minimal()
plot_tau <- mcmc_areas(draws, pars = vars(starts_with("Log-Tau")), prob = 0.95) +
ggtitle("Decision Noise (Log-Tau) by Condition and Context") +
theme_minimal()
plot_kappa
plot_tau
plot_tau
