travel_cost
warnings()
travel_cost <- coded_d %>%
filter(droga == "na_na_na_na", A %in% c(4, 5, 6), n_sesion %in% c(15, 16, 17)) %>%
group_by(ID) %>%
mutate(
is_leave = A == 4,
is_lick = A %in% c(5, 6),
travel_group = cumsum(is_leave)
) %>%
filter(is_leave | is_lick) %>%
ungroup() %>%
group_by(ID, travel_group) %>%
mutate(
travel_time = if_else(n() >= 2, min(timestamp[A != 4], na.rm = TRUE) - timestamp[1], NA)
)
# travel costs ----
travel_cost <- coded_d %>%
filter(droga == "na_na_na_na", A %in% c(4, 5, 6), n_sesion %in% c(15, 16, 17)) %>%
group_by(ID) %>%
mutate(
is_leave = A == 4,
is_lick = A %in% c(5, 6),
travel_group = cumsum(is_leave)
) %>%
filter(is_leave | is_lick) %>%
ungroup() %>%
group_by(ID, travel_group) %>%
mutate(
travel_time = if_else(n() >= 2, min(timestamp[A != 4], na.rm = TRUE) - timestamp[1], NA)
) %>%
slice_head(., n = 1) %>%
filter(travel_time > 0) %>%
ungroup() %>%
group_by(ID) %>%
summarise(
fast_travel = quantile(x = travel_time, 0.10, na.rm = TRUE)
)
travel_cost
travel_cost %>%
ggplot(aes(travel_time)) +
geom_density()
# travel costs ----
travel_cost <- coded_d %>%
filter(droga == "na_na_na_na", A %in% c(4, 5, 6), n_sesion %in% c(15, 16, 17)) %>%
group_by(ID) %>%
mutate(
is_leave = A == 4,
is_lick = A %in% c(5, 6),
travel_group = cumsum(is_leave)
) %>%
filter(is_leave | is_lick) %>%
ungroup() %>%
group_by(ID, travel_group) %>%
mutate(
travel_time = if_else(n() >= 2, min(timestamp[A != 4], na.rm = TRUE) - timestamp[1], NA)
) %>%
slice_head(., n = 1) %>%
filter(travel_time > 0) %>%
ungroup() %>%
group_by(ID) %>%
summarise(
fast_travel = quantile(x = travel_time, 0.10, na.rm = TRUE)
)
travel_cost
# libs ----
pacman::p_load(
tidyverse,
ggplot2,
furrr
)
# source lickometer library
devtools::source_url("https://github.com/lab-cpl/lickometer-library/blob/main/src/lickometer_functions_compilate.R?raw=TRUE")
# set working directory
setwd(this.path::here())
# load data ----
data_path <- "../data/lickometer_raw/"
metadata <- "../metadata/lickometer_metadata.csv"
d <- load_experiment(metadataFileName = metadata, data_directory_path = data_path) %>%
mutate(
true_context = paste(
str_extract(estimulo_spout_1, pattern = "[0-9]+prob"),
str_extract(estimulo_spout_2, pattern = "[0-9]+prob"),
sep = "-"
),
true_context = case_when(
true_context == "100prob-100prob" ~ "C_T",
true_context == "50prob-100prob" ~ "C_S2a",
true_context == "100prob-50prob" ~ "C_S2b",
true_context == "25prob-50prob" ~ "C_S3a",
true_context == "50prob-25prob" ~ "C_S3b"
)
)
d
# create data ----
# set timestamp relative for each animal
TIME_STEP <- 25
CORES <- parallel::detectCores()
plan(multisession, workers = CORES)
create_data <- d %>%
group_by(ID, n_sesion) %>%
group_split() %>%
map(., function(dat) {
## status ----
# first part to set the nosepoke time
# creates groups for nosepoking instances
nosepoke <- dat %>%
mutate(
timestamp = tiempo - min(tiempo),
timestamp_discrete = trunc(timestamp / TIME_STEP) * TIME_STEP,
nosepoke = if_else(actividad == -1, TRUE, FALSE),
evento = if_else(nosepoke == TRUE, "-1", evento),
nosepoke_time = if_else(nosepoke, timestamp, 0),
nosepoke_time = if_else(lag(nosepoke) == FALSE, 0,
nosepoke_time - lag(nosepoke_time, n = 1)
) %>% replace_na(., 0) %>% pmax(., 0),
nosepoke_group = data.table::rleid(nosepoke)
) %>%
ungroup() %>%
group_by(nosepoke_group) %>%
# only nosepoke instances are non-zero timings
# this is to determine when the nosepoke was valid
mutate(nosepoke_time = cumsum(nosepoke_time)) %>%
ungroup() %>%
group_by(sensor) %>%
# first part to determine if task is armed
# task is not armed when an event is triggered
# task is armed when animal is on nosepoke > 50 ms
# for now everything else in undetermined
mutate(
task_armed = case_when(
evento != lag(evento) & nosepoke == FALSE ~ FALSE,
nosepoke_time >= 50 ~ TRUE
),
# this is to detect if animal is idle
# assumption is : animal is not licking for 250 ms or more
# the its idle
idle = if_else(actividad != lag(actividad) & # just in case of log error
nosepoke == FALSE & # do not consider time in nosepoke as idle
timestamp - lag(timestamp) >= TIME_STEP * 100, # threshold for being idle
TRUE, FALSE
) %>% replace_na(., TRUE), # idle is the default state
# this is to detect if licking activity is related to a reward
rewarded = case_when(
evento != lag(evento) & exito != lag(exito) & nosepoke == FALSE & lag(nosepoke == FALSE) ~ TRUE,
evento != lag(evento) & exito == lag(exito) & nosepoke == FALSE & lag(nosepoke == FALSE) ~ FALSE,
nosepoke == TRUE ~ FALSE
) %>% zoo::na.locf(., na.rm = FALSE) %>% replace_na(., FALSE)
) %>%
ungroup() %>%
group_by(sensor, evento) %>%
mutate(
# this is to detect when the animal is doing the FR5 part
licks_rel = actividad - min(actividad) + 1,
accum = if_else(licks_rel <= 4 &
nosepoke == FALSE, TRUE, FALSE)
) %>%
ungroup() %>%
mutate(
# fill down
# when task becomes not armed it will stay that way
# until it becomes armed again, it will stay armed
# until it becomes not armed again ...
task_armed = zoo::na.locf(task_armed, na.rm = FALSE) %>%
replace_na(., TRUE) # task armed by default
) %>%
ungroup()
## sampling ----
sampling_data <- tibble(timestamp_discrete = seq(0, max(nosepoke$timestamp),
by = TIME_STEP
))
discrete_data <- sampling_data %>%
left_join(., nosepoke, by = c("timestamp_discrete")) %>%
ungroup() %>%
mutate(
# datum is a record, non datum are derived records
is_datum = if_else(is.na(nosepoke), FALSE, TRUE),
task_armed = zoo::na.locf(task_armed, na.rm = FALSE),
idle = zoo::na.locf(idle, na.rm = FALSE, fromLast = TRUE),
rewarded = zoo::na.locf(rewarded, na.rm = FALSE),
nosepoke = zoo::na.locf(nosepoke, na.rm = FALSE, fromLast = TRUE),
ID = zoo::na.locf(ID, na.rm = FALSE),
sensor = zoo::na.locf(sensor, na.rm = FALSE),
accum = zoo::na.locf(accum, na.rm = FALSE, fromLast = TRUE),
licks_rel = zoo::na.locf(licks_rel, na.rm = FALSE, fromLast = TRUE),
n_sesion = zoo::na.locf(n_sesion, na.rm = FALSE),
droga = zoo::na.locf(droga, na.rm = FALSE),
dosis = zoo::na.locf(dosis, na.rm = FALSE),
tipo_recompensa = zoo::na.locf(tipo_recompensa, na.rm = FALSE),
true_context = zoo::na.locf(true_context, na.rm = FALSE)
) %>%
select(
ID, n_sesion, droga, dosis, true_context, tipo_recompensa,
is_datum, timestamp_discrete, nosepoke, task_armed,
idle, rewarded, accum, sensor, evento, licks_rel,
timestamp, is_datum
) %>%
## states and action ----
mutate(
# this is the state definitions
S = case_when(
idle == TRUE & nosepoke == FALSE ~ "S_I",
nosepoke == TRUE & task_armed == FALSE ~ "S_P1",
nosepoke == TRUE & task_armed == TRUE ~ "S_P2",
nosepoke == FALSE & task_armed == TRUE & sensor == 0 & accum == TRUE ~ paste("S", licks_rel, "0", sep = "_"),
nosepoke == FALSE & task_armed == TRUE & sensor == 1 & accum == TRUE ~ paste("S", "0", licks_rel, sep = "_"),
accum == FALSE & nosepoke == FALSE & rewarded == TRUE ~ "S_CR",
accum == FALSE & nosepoke == FALSE & rewarded == FALSE ~ "S_CN",
nosepoke == FALSE & task_armed == TRUE ~ "S_Armed",
.default = "S_I"
),
# this is the action definitions
A = case_when(
lead(S) == "S_P1" ~ "a_P",
lead(S) == "S_P2" ~ "a_SP",
S %in% c("S_P1", "S_P2") & !(lead(S) %in% c("S_P1", "S_P2")) ~ "a_LP",
grepl(pattern = "S_[0-9]_[0-9]", x = lead(S)) & lead(S) != S & sensor == 0 ~ "a_L1",
grepl(pattern = "S_[0-9]_[0-9]", x = lead(S)) & lead(S) != S & sensor == 1 ~ "a_L2",
lead(S) %in% c("S_CR", "S_CN") & sensor == 0 ~ "a_L1",
lead(S) %in% c("S_CR", "S_CN") & sensor == 1 ~ "a_L2",
lead(S) == "S_I" ~ "a_W"
),
# this is to fill lick related data
# a sequence a_L1 -> a_W -> a_L1, is representing a lick 25ms.
# then another lick an so on , number of a_W between a_L1
# is the interlick interval discretized approximation
A = if_else(is.na(A) & grepl(pattern = "S_[0-9]_[0-9]|S_CR|S_CN|S_Armed", x = S), "a_W", A)
) %>%
select(
ID, is_datum, timestamp, timestamp_discrete, n_sesion,
droga, dosis, true_context, tipo_recompensa, A, S
)
return(discrete_data)
})
# save data ----
saveRDS(object = bind_rows(create_data), file = "../data/processed/discrete_data.rds")
# libs ----
pacman::p_load(
tidyverse,
cmdstanr,
posterior,
bayesplot
)
# set working directory
setwd(this.path::here())
# load data ----
d <- readRDS("../data/processed/discrete_data.rds")
# coding A and S ----
# this is necessary for bayesian fit
coded_d <- d %>%
mutate(
A = case_when(
# wait
A == "a_W" ~ 1,
# nose into poke
A == "a_P" ~ 2,
# stay in the poke
A == "a_SP" ~ 3,
# leave the poke
A == "a_LP" ~ 4,
# lick in spout 0
A == "a_L1" ~ 5,
# lick in spout 1
A == "a_L2" ~ 6
),
S = case_when(
# idle
S == "S_I" ~ 1,
# poke transient
S == "S_P1" ~ 2,
# poke valid
S == "S_P2" ~ 3,
# the task is armed but nothing is happening
S == "S_Armed" ~ 4,
# left chain of FR5
S == "S_1_0" ~ 5,
S == "S_2_0" ~ 6,
S == "S_3_0" ~ 7,
S == "S_4_0" ~ 8,
# right chain of FR5
S == "S_0_1" ~ 9,
S == "S_0_2" ~ 10,
S == "S_0_3" ~ 11,
S == "S_0_4" ~ 12,
# consuming reward
S == "S_CR" ~ 99,
# consuming no-reward
S == "S_CN" ~ 100
)
)
# Physics calibration -----
# the model uses 'ideal' conditions and then determines deviations from it
# the most relevant mechanic in the task is to get a reward
# to do so you require some time in nosepoke + travel to spout + FR5
# in order to get good baseline level we use training data from last 3 session
# and determine this time cost as follows:
# nosepoke = 50 ms (this is a constant, set by the task)
# travel time = the 10th percentile of the distribution over the lengths a_LP -> first lick
# FR5 = the 10th percetile of the ILI within FR5
# lick costs ----
fr5_cost <- coded_d %>%
filter(droga == "na_na_na_na", is_datum == TRUE, n_sesion %in% c(15, 16, 17)) %>%
group_by(ID) %>%
mutate(
ILI = timestamp - lag(timestamp)
) %>%
filter(
# exclude the first one because it computes time between non-lick
# and an actual lick from FR5
S %in% c(5, 6, 7, 9, 10, 10),
# exclude clear disengagement
ILI <= 1000
) %>%
summarise(
mean_ili = mean(ILI)
)
fr5_cost
# travel costs ----
travel_cost <- coded_d %>%
filter(droga == "na_na_na_na", A %in% c(4, 5, 6), n_sesion %in% c(15, 16, 17)) %>%
group_by(ID) %>%
mutate(
is_leave = A == 4,
is_lick = A %in% c(5, 6),
travel_group = cumsum(is_leave)
) %>%
filter(is_leave | is_lick) %>%
ungroup() %>%
group_by(ID, travel_group) %>%
mutate(
travel_time = if_else(n() >= 2, min(timestamp[A != 4], na.rm = TRUE) - timestamp[1], NA)
) %>%
slice_head(., n = 1) %>%
filter(travel_time > 0) %>%
ungroup() %>%
group_by(ID) %>%
summarise(
fast_travel = quantile(x = travel_time, 0.10, na.rm = TRUE)
)
travel_cost
?saveRDS
# libs ----
pacman::p_load(
tidyverse,
ggplot2,
furrr
)
# source lickometer library
devtools::source_url("https://github.com/lab-cpl/lickometer-library/blob/main/src/lickometer_functions_compilate.R?raw=TRUE")
# set working directory
setwd(this.path::here())
# load data ----
data_path <- "../data/lickometer_raw/"
metadata <- "../metadata/lickometer_metadata.csv"
d <- load_experiment(metadataFileName = metadata, data_directory_path = data_path) %>%
mutate(
true_context = paste(
str_extract(estimulo_spout_1, pattern = "[0-9]+prob"),
str_extract(estimulo_spout_2, pattern = "[0-9]+prob"),
sep = "-"
),
true_context = case_when(
true_context == "100prob-100prob" ~ "C_T",
true_context == "50prob-100prob" ~ "C_S2a",
true_context == "100prob-50prob" ~ "C_S2b",
true_context == "25prob-50prob" ~ "C_S3a",
true_context == "50prob-25prob" ~ "C_S3b"
)
)
d
# create data ----
# set timestamp relative for each animal
TIME_STEP <- 25
CORES <- parallel::detectCores()
plan(multisession, workers = CORES)
create_data <- d %>%
group_by(ID, n_sesion) %>%
group_split() %>%
map(., function(dat) {
## status ----
# first part to set the nosepoke time
# creates groups for nosepoking instances
nosepoke <- dat %>%
mutate(
timestamp = tiempo - min(tiempo),
timestamp_discrete = trunc(timestamp / TIME_STEP) * TIME_STEP,
nosepoke = if_else(actividad == -1, TRUE, FALSE),
evento = if_else(nosepoke == TRUE, "-1", evento),
nosepoke_time = if_else(nosepoke, timestamp, 0),
nosepoke_time = if_else(lag(nosepoke) == FALSE, 0,
nosepoke_time - lag(nosepoke_time, n = 1)
) %>% replace_na(., 0) %>% pmax(., 0),
nosepoke_group = data.table::rleid(nosepoke)
) %>%
ungroup() %>%
group_by(nosepoke_group) %>%
# only nosepoke instances are non-zero timings
# this is to determine when the nosepoke was valid
mutate(nosepoke_time = cumsum(nosepoke_time)) %>%
ungroup() %>%
group_by(sensor) %>%
# first part to determine if task is armed
# task is not armed when an event is triggered
# task is armed when animal is on nosepoke > 50 ms
# for now everything else in undetermined
mutate(
task_armed = case_when(
evento != lag(evento) & nosepoke == FALSE ~ FALSE,
nosepoke_time >= 50 ~ TRUE
),
# this is to detect if animal is idle
# assumption is : animal is not licking for 250 ms or more
# the its idle
idle = if_else(actividad != lag(actividad) & # just in case of log error
nosepoke == FALSE & # do not consider time in nosepoke as idle
timestamp - lag(timestamp) >= TIME_STEP * 100, # threshold for being idle
TRUE, FALSE
) %>% replace_na(., TRUE), # idle is the default state
# this is to detect if licking activity is related to a reward
rewarded = case_when(
evento != lag(evento) & exito != lag(exito) & nosepoke == FALSE & lag(nosepoke == FALSE) ~ TRUE,
evento != lag(evento) & exito == lag(exito) & nosepoke == FALSE & lag(nosepoke == FALSE) ~ FALSE,
nosepoke == TRUE ~ FALSE
) %>% zoo::na.locf(., na.rm = FALSE) %>% replace_na(., FALSE)
) %>%
ungroup() %>%
group_by(sensor, evento) %>%
mutate(
# this is to detect when the animal is doing the FR5 part
licks_rel = actividad - min(actividad) + 1,
accum = if_else(licks_rel <= 4 &
nosepoke == FALSE, TRUE, FALSE)
) %>%
ungroup() %>%
mutate(
# fill down
# when task becomes not armed it will stay that way
# until it becomes armed again, it will stay armed
# until it becomes not armed again ...
task_armed = zoo::na.locf(task_armed, na.rm = FALSE) %>%
replace_na(., TRUE) # task armed by default
) %>%
ungroup()
## sampling ----
sampling_data <- tibble(timestamp_discrete = seq(0, max(nosepoke$timestamp),
by = TIME_STEP
))
discrete_data <- sampling_data %>%
left_join(., nosepoke, by = c("timestamp_discrete")) %>%
ungroup() %>%
mutate(
# datum is a record, non datum are derived records
is_datum = if_else(is.na(nosepoke), FALSE, TRUE),
task_armed = zoo::na.locf(task_armed, na.rm = FALSE),
idle = zoo::na.locf(idle, na.rm = FALSE, fromLast = TRUE),
rewarded = zoo::na.locf(rewarded, na.rm = FALSE),
nosepoke = zoo::na.locf(nosepoke, na.rm = FALSE, fromLast = TRUE),
ID = zoo::na.locf(ID, na.rm = FALSE),
sensor = zoo::na.locf(sensor, na.rm = FALSE),
accum = zoo::na.locf(accum, na.rm = FALSE, fromLast = TRUE),
licks_rel = zoo::na.locf(licks_rel, na.rm = FALSE, fromLast = TRUE),
n_sesion = zoo::na.locf(n_sesion, na.rm = FALSE),
droga = zoo::na.locf(droga, na.rm = FALSE),
dosis = zoo::na.locf(dosis, na.rm = FALSE),
tipo_recompensa = zoo::na.locf(tipo_recompensa, na.rm = FALSE),
true_context = zoo::na.locf(true_context, na.rm = FALSE)
) %>%
select(
ID, n_sesion, droga, dosis, true_context, tipo_recompensa,
is_datum, timestamp_discrete, nosepoke, task_armed,
idle, rewarded, accum, sensor, evento, licks_rel,
timestamp, is_datum
) %>%
## states and action ----
mutate(
# this is the state definitions
S = case_when(
idle == TRUE & nosepoke == FALSE ~ "S_I",
nosepoke == TRUE & task_armed == FALSE ~ "S_P1",
nosepoke == TRUE & task_armed == TRUE ~ "S_P2",
nosepoke == FALSE & task_armed == TRUE & sensor == 0 & accum == TRUE ~ paste("S", licks_rel, "0", sep = "_"),
nosepoke == FALSE & task_armed == TRUE & sensor == 1 & accum == TRUE ~ paste("S", "0", licks_rel, sep = "_"),
accum == FALSE & nosepoke == FALSE & rewarded == TRUE ~ "S_CR",
accum == FALSE & nosepoke == FALSE & rewarded == FALSE ~ "S_CN",
nosepoke == FALSE & task_armed == TRUE ~ "S_Armed",
.default = "S_I"
),
# this is the action definitions
A = case_when(
lead(S) == "S_P1" ~ "a_P",
lead(S) == "S_P2" ~ "a_SP",
S %in% c("S_P1", "S_P2") & !(lead(S) %in% c("S_P1", "S_P2")) ~ "a_LP",
grepl(pattern = "S_[0-9]_[0-9]", x = lead(S)) & lead(S) != S & sensor == 0 ~ "a_L1",
grepl(pattern = "S_[0-9]_[0-9]", x = lead(S)) & lead(S) != S & sensor == 1 ~ "a_L2",
lead(S) %in% c("S_CR", "S_CN") & sensor == 0 ~ "a_L1",
lead(S) %in% c("S_CR", "S_CN") & sensor == 1 ~ "a_L2",
lead(S) == "S_I" ~ "a_W"
),
# this is to fill lick related data
# a sequence a_L1 -> a_W -> a_L1, is representing a lick 25ms.
# then another lick an so on , number of a_W between a_L1
# is the interlick interval discretized approximation
A = if_else(is.na(A) & grepl(pattern = "S_[0-9]_[0-9]|S_CR|S_CN|S_Armed", x = S), "a_W", A)
) %>%
select(
ID, is_datum, timestamp, timestamp_discrete, n_sesion,
droga, dosis, true_context, tipo_recompensa, A, S
)
return(discrete_data)
})
# save data ----
saveRDS(object = bind_rows(create_data), file = "../data/processed/discrete_data.rds", compress = TRUE)
