)
# sell rule
add.rule(
strategy = strategy_st,
name = "ruleSignal",
arguments = list(
sigcol = "ExitSignal",
sigval = TRUE,
orderqty = "all",
ordertype = "limit",
orderside = "long",
replace = FALSE,
),
type = "exit",
label = "ExitRule"
)
rm(list = ls())
# libs ----
pacman::p_load(
quantmod,
TTR,
PerformanceAnalytics
)
# this libs were removed from CRAN
pacman::p_load_gh(
"braverock/FinancialInstrument",
"braverock/quantstrat",
"braverock/blotter"
)
# set time zone
Sys.setenv(tz = "UTC")
# set data ----
start_date <- "2000-01-01"
getSymbols("SPY",
src = "yahoo",
from = start_date,
auto.assign = TRUE
)
# define instrument
currency("USD")
stock("SPY",
currency = "USD",
multiplier = 1
)
# set strats ----
strategy_st <- "mean_revert"
portfolio_st <- "mean_revert"
account_st <- "mean_revert"
# clean old runs
.blotter <- new.env()
.strategy <- new.env()
rm.strat(strategy_st)
rm.strat(portfolio_st)
rm.strat(account_st)
# init portfolio ----
init_date <- "1999-12-31"
init_eq <- 10000
initPortf(
portfolio_st,
symbols = "SPY",
initDate = init_date,
currency = "USD",
initEq = init_eq
)
initAcct(
account_st,
portfolios = portfolio_st,
initDate = init_date,
currency = "USD",
initEq = init_eq
)
initOrders(
portfolio_st,
initDate = init_date
)
# define portfolio position limit
addPosLimit(
portfolio = portfolio_st,
symbol = "SPY",
timestamp = init_date,
maxpos = 100,
minpos = 0
)
strategy(
strategy_st,
store = TRUE
)
# add indicator ----
add.indicator(
strategy = strategy_st,
name = "EMA",
arguments = list(x = quote(Cl(mktdata)), n = 50),
label = "ema_50"
)
# buy signal
add.signal(
strategy = strategy_st,
name = "sigComparison",
arguments = list(
columns = c("Close", "ema_50"),
relationship = "lt"
),
label = "BuySignal"
)
# buy rule
add.rule(
strategy = strategy_st,
name = "ruleSignal",
arguments = list(
sigcol = "BuySignal",
sigval = TRUE,
orderqty = 100,
ordertype = "market",
orderside = "long",
osFUN = osMaxPos,
replace = FALSE,
orderset = "ProfitTakerSet"
),
type = "enter",
label = "EnterRule"
)
# sell rule
add.rule(
strategy = strategy_st,
name = "ruleSignal",
arguments = list(
sigcol = "ExitSignal",
sigval = TRUE,
orderqty = "all",
ordertype = "limit",
orderside = "long",
replace = FALSE,
),
type = "exit",
label = "ExitRule"
)
rm(list = ls())
# libs ----
pacman::p_load(
quantmod,
TTR,
PerformanceAnalytics
)
# this libs were removed from CRAN
pacman::p_load_gh(
"braverock/FinancialInstrument",
"braverock/quantstrat",
"braverock/blotter"
)
# set time zone
Sys.setenv(tz = "UTC")
# set data ----
start_date <- "2000-01-01"
getSymbols("SPY",
src = "yahoo",
from = start_date,
auto.assign = TRUE
)
# define instrument
currency("USD")
stock("SPY",
currency = "USD",
multiplier = 1
)
# set strats ----
strategy_st <- "mean_revert"
portfolio_st <- "mean_revert"
account_st <- "mean_revert"
# clean old runs
.blotter <- new.env()
.strategy <- new.env()
rm.strat(strategy_st)
rm.strat(portfolio_st)
rm.strat(account_st)
# init portfolio ----
init_date <- "1999-12-31"
init_eq <- 10000
initPortf(
portfolio_st,
symbols = "SPY",
initDate = init_date,
currency = "USD",
initEq = init_eq
)
initAcct(
account_st,
portfolios = portfolio_st,
initDate = init_date,
currency = "USD",
initEq = init_eq
)
initOrders(
portfolio_st,
initDate = init_date
)
# define portfolio position limit
addPosLimit(
portfolio = portfolio_st,
symbol = "SPY",
timestamp = init_date,
maxpos = 100,
minpos = 0
)
strategy(
strategy_st,
store = TRUE
)
# add indicator ----
add.indicator(
strategy = strategy_st,
name = "EMA",
arguments = list(x = quote(Cl(mktdata)), n = 50),
label = "ema_50"
)
# buy signal
add.signal(
strategy = strategy_st,
name = "sigComparison",
arguments = list(
columns = c("Close", "ema_50"),
relationship = "lt"
),
label = "BuySignal"
)
# buy rule
add.rule(
strategy = strategy_st,
name = "ruleSignal",
arguments = list(
sigcol = "BuySignal",
sigval = TRUE,
orderqty = 100,
ordertype = "market",
orderside = "long",
osFUN = osMaxPos,
replace = FALSE,
orderset = "ProfitTakerSet"
),
type = "enter",
label = "EnterRule"
)
# sell rule
add.rule(
strategy = strategy_st,
name = "ruleSignal",
arguments = list(
sigcol = "ExitSignal",
sigval = TRUE,
orderqty = "all",
ordertype = "market",
orderside = "long",
replace = FALSE,
),
type = "exit",
label = "ExitRule"
)
s <- seq(0, 1, by = 0.001)
plot(abs(s)^-1, type = "l")
plot(abs(s)^-1, type = "l")
pacman::p_load(
tidyverse, posterior, bayesplot, patchwork, scales, this.path
)
setwd(this.path::here())
# 1. LOAD FIT AND EXTRACT TARGETS ----
fit <- readRDS("../results/fit_full_volatility_final.rds")
# We target [1,1] (Naive/Baseline) as the primary diagnostic anchor.
target_idx <- "[1,1]"
vars_to_plot <- c(
paste0("mu_beta", target_idx),
paste0("mu_log_tau", target_idx)
)
# Preserve the 'Chain' dimension to diagnose the divergence
draws_array <- fit$draws(variables = vars_to_plot)
# Create a chain-aware data frame for diagnostics
draws_df <- as_draws_df(draws_array) %>%
mutate(
mu_tau = exp(.data[[paste0("mu_log_tau", target_idx)]]),
Chain = as.factor(.chain)
)
# 2. CHAIN-AWARE JOINT POSTERIOR (IDENTIFYING ISLANDS) ----
# Categorical Intuition: Mapping the 'Island' problem.
# If the divergent chain is a different color in a different region,
# the manifold is multi-modal or poorly identified.
p_joint <- ggplot(draws_df, aes(x = .data[[paste0("mu_beta", target_idx)]], y = mu_tau, color = Chain)) +
geom_point(alpha = 0.2, size = 0.5) +
geom_density_2d(alpha = 0.5) +
scale_color_viridis_d() +
theme_minimal() +
labs(
title = "Chain-Aware Joint Posterior",
subtitle = "Check if the divergent chain (color) is isolated from the others.",
x = "Motivation (mu_beta)",
y = "Decision Noise (mu_tau)"
) +
guides(color = guide_legend(override.aes = list(alpha = 1, size = 2)))
# 3. TRACE OVERLAP (THE PATH MORPHISM) ----
color_scheme_set("viridis")
p_trace <- mcmc_trace(
draws_array,
pars = vars_to_plot,
facet_args = list(ncol = 1, strip.position = "left")
) +
theme_minimal() +
labs(
title = "Chain Trajectories (Divergence Check)",
subtitle = "A divergent chain will appear as a 'wandering' line outside the main caterpillar."
)
# 4. MARGINAL DENSITIES BY CHAIN ----
p_dens <- mcmc_dens_overlay(draws_array, pars = vars_to_plot) +
theme_minimal() +
labs(title = "Overlaid Marginal Densities")
# 5. ASSEMBLY ----
final_diag <- (p_joint | (p_dens / p_trace)) +
plot_layout(widths = c(2, 1))
p_trace
pacman::p_load(
tidyverse, posterior, bayesplot, patchwork, scales, this.path
)
setwd(this.path::here())
# 1. LOAD FIT AND EXTRACT TARGETS ----
fit <- readRDS("../results/fit_full_volatility_final.rds")
# We target [1,1] (Naive/Baseline) as the primary diagnostic anchor.
target_idx <- "[1,1]"
vars_to_plot <- c(
paste0("mu_beta", target_idx),
paste0("mu_log_tau", target_idx)
)
# Preserve the 'Chain' dimension to diagnose the divergence
draws_array <- fit$draws(variables = vars_to_plot)
# Create a chain-aware data frame for diagnostics
draws_df <- as_draws_df(draws_array) %>%
mutate(
mu_tau = exp(.data[[paste0("mu_log_tau", target_idx)]]),
Chain = as.factor(.chain)
)
# 2. CHAIN-AWARE JOINT POSTERIOR (IDENTIFYING ISLANDS) ----
# Categorical Intuition: Mapping the 'Island' problem.
# If the divergent chain is a different color in a different region,
# the manifold is multi-modal or poorly identified.
p_joint <- ggplot(draws_df, aes(x = .data[[paste0("mu_beta", target_idx)]], y = mu_tau, color = Chain)) +
geom_point(alpha = 0.2, size = 0.5) +
geom_density_2d(alpha = 0.5) +
scale_color_viridis_d() +
theme_minimal() +
labs(
title = "Chain-Aware Joint Posterior",
subtitle = "Check if the divergent chain (color) is isolated from the others.",
x = "Motivation (mu_beta)",
y = "Decision Noise (mu_tau)"
) +
guides(color = guide_legend(override.aes = list(alpha = 1, size = 2)))
# 3. TRACE OVERLAP (THE PATH MORPHISM) ----
color_scheme_set("viridis")
p_trace <- mcmc_trace(
draws_array,
pars = vars_to_plot,
facet_args = list(ncol = 1, strip.position = "left")
) +
theme_minimal() +
labs(
title = "Chain Trajectories (Divergence Check)",
subtitle = "A divergent chain will appear as a 'wandering' line outside the main caterpillar."
)
# 4. MARGINAL DENSITIES BY CHAIN ----
p_dens <- mcmc_dens_overlay(draws_array, pars = vars_to_plot) +
theme_minimal() +
labs(title = "Overlaid Marginal Densities")
p_trace
p_joint
draws_df
# 3. GLOBAL CONVERGENCE STATS (R-hat and ESS) ----
# Formalization: All paths must be rank-isomorphic (R-hat < 1.05)
# and have sufficient resolution (ESS > 400).
fit_summary <- fit$summary(variables = c("mu_beta", "mu_kappa", "mu_log_tau", "sigma_beta_trait"))
cat("\n--- Convergence Summary (Top Parameters) ---\n")
print(head(fit_summary %>% arrange(desc(rhat)), 10))
# 4. VISUALIZATION: THE FUZZY CATERPILLAR TEST ----
# Categorical Intuition: Chains should be indistinguishable fibers.
target_params <- c("mu_beta[1,1]", "mu_log_tau[1,1]")
draws_array <- fit$draws(variables = target_params)
p_trace <- mcmc_trace(draws_array) +
theme_minimal() +
labs(title = "Chain Overlap (The Caterpillar Test)")
p_trace
# 5. VISUALIZATION: POSTERIOR UNIFICATION ----
# Logic: Checks if multiple peaks have collapsed into a single mode.
p_dens <- mcmc_dens_overlay(draws_array) +
theme_minimal() +
labs(title = "Unified Marginal Posterior")
p_dens
# 6. JOINT MANIFOLD: BETA-TAU IDENTIFIABILITY ----
# Logic: Checks if the 0.01 correlation is maintained in the final limit.
draws_df <- as_draws_df(draws_array) %>%
mutate(mu_tau = exp(`mu_log_tau[1,1]`))
p_joint <- ggplot(draws_df, aes(x = `mu_beta[1,1]`, y = mu_tau)) +
geom_bin2d(bins = 40) +
scale_fill_viridis_c(option = "plasma") +
geom_density_2d(color = "white", alpha = 0.3) +
theme_minimal() +
labs(
title = "Joint Posterior: Vigor vs. Noise",
x = "Motivation (mu_beta)", y = "Decision Noise (mu_tau)"
)
p_joint
# 7. ASSEMBLY AND EXPORT ----
diag_plot <- (p_trace / p_dens) | p_joint
diag_plot
fit_summary
sampler_diags <- fit$sampler_diagnostics()
calc_ebfmi <- function(energy_vec) {
sum(diff(energy_vec)^2) / (length(energy_vec) * var(energy_vec))
}
calc_ebfmi()
calc_ebfmi
ebfmi_vals <- apply(sampler_diags[, , "energy__"], 2, calc_ebfmi)
div_counts <- apply(sampler_diags[, , "divergent__"], 2, sum)
max_td <- apply(sampler_diags[, , "treedepth__"], 2, max)
ebfmi_vals
message("--- NUTS Sampler Audit ---")
for (i in 1:length(ebfmi_vals)) {
message(paste0(
"Chain ", i,
" | E-BFMI: ", round(ebfmi_vals[i], 3),
" | Div: ", div_counts[i],
" | Max TD: ", max_td[i]
))
}
fit_summary <- fit$summary(
variables = c("mu_beta", "mu_kappa", "mu_log_tau", "sigma_beta_trait", "sigma_beta_session"),
.rhat = posterior::rhat,
.ess_bulk = posterior::ess_bulk,
.ess_tail = posterior::ess_tail
)
fit_summary
View(fit_summary)
pacman::p_load(
tidyverse, cmdstanr, posterior, bayesplot, patchwork, scales, this.path
)
setwd(this.path::here())
# 1. LOAD FIT OBJECT ----
# retrieves the limit object of the hamiltonian flow.
fit <- readRDS("../results/fit_full_volatility_final.rds")
# 2. SAMPLER DIAGNOSTICS (E-BFMI, Divergences, Treedepth) ----
# Categorical Logic: Measuring the 'Efficiency Functor'
# E-BFMI > 0.3 confirms that energy transitions are faithful to the manifold.
sampler_diags <- fit$sampler_diagnostics()
calc_ebfmi <- function(energy_vec) {
sum(diff(energy_vec)^2) / (length(energy_vec) * var(energy_vec))
}
ebfmi_vals <- apply(sampler_diags[, , "energy__"], 2, calc_ebfmi)
div_counts <- apply(sampler_diags[, , "divergent__"], 2, sum)
max_td     <- apply(sampler_diags[, , "treedepth__"], 2, max)
message("--- NUTS Sampler Audit ---")
for(i in 1:length(ebfmi_vals)) {
message(paste0("Chain ", i,
" | E-BFMI: ", round(ebfmi_vals[i], 3),
" | Div: ", div_counts[i],
" | Max TD: ", max_td[i]))
}
fit_summary <- fit$summary(
variables = c("mu_beta", "mu_kappa", "mu_log_tau", "sigma_beta_trait", "sigma_beta_session"),
.rhat = posterior::rhat,
.ess_bulk = posterior::ess_bulk,
.ess_tail = posterior::ess_tail
)
cat("\n--- Convergence Summary (Cognitive Parameters) ---\n")
print(fit_summary)
# 4. CHAIN-WISE DISCREPANCY CHECK (FOR R-HAT > 1.1) ----
# Categorical Logic: Identifying the 'Island' occupied by each Chain Morphism.
# If R-hat is high, this table reveals which chain is the outlier.
cat("\n--- Chain-Wise Parameter Medians (Identifying the 'Island') ---\n")
target_vars <- c("mu_beta[1,1]", "mu_log_tau[1,1]")
draws_all <- fit$draws(variables = target_vars)
chain_medians <- draws_all %>%
summarise_draws(median, .chain = TRUE) %>%
select(chain, variable, median) %>%
pivot_wider(names_from = variable, values_from = median)
print(chain_medians)
# Logic: Automatic Identification of Parameters that fail the 'limit object' criteria.
problematic_params <- fit$summary() %>%
filter(rhat > 1.05 | ess_bulk < 400) %>%
arrange(desc(rhat))
if(nrow(problematic_params) > 0) {
cat("\n--- WARNING: Parameters failing convergence criteria ---\n")
cat("A high R-hat (e.g., > 1.1) means the chains are NOT in the same mode.\n")
print(head(problematic_params, 20))
} else {
cat("\nSUCCESS: All parameters satisfy R-hat < 1.05 and ESS > 400.\n")
}
# 5. VISUALIZATION: THE FUZZY CATERPILLAR TEST ----
# Categorical Intuition: Chains should be indistinguishable fibers.
draws_array <- fit$draws(variables = target_vars)
p_trace <- mcmc_trace(draws_array) +
theme_minimal() +
labs(title = "Chain Overlap (The Caterpillar Test)")
# 6. VISUALIZATION: POSTERIOR UNIFICATION ----
p_dens <- mcmc_dens_overlay(draws_array) +
theme_minimal() +
labs(title = "Unified Marginal Posterior")
# 7. JOINT MANIFOLD: BETA-TAU IDENTIFIABILITY ----
draws_df <- as_draws_df(draws_array) %>%
mutate(mu_tau = exp(`mu_log_tau[1,1]`))
p_joint <- ggplot(draws_df, aes(x = `mu_beta[1,1]`, y = mu_tau)) +
geom_bin2d(bins = 40) +
scale_fill_viridis_c(option = "plasma") +
geom_density_2d(color = "white", alpha = 0.3) +
theme_minimal() +
labs(title = "Joint Posterior: Vigor vs. Noise",
x = "Motivation (mu_beta)", y = "Decision Noise (mu_tau)")
# 8. ASSEMBLY AND EXPORT ----
diag_plot <- (p_trace / p_dens) | p_joint
diag_plot
